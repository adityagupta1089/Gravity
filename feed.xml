<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aditya Gupta's Blog</title>
    <description></description>
    <link>https://adityagupta1089.github.io/</link>
    <atom:link href="https://adityagupta1089.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 01 Nov 2019 14:44:53 +0000</pubDate>
    <lastBuildDate>Fri, 01 Nov 2019 14:44:53 +0000</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>Convex Hull</title>
        <description>&lt;h1 id=&quot;notation&quot;&gt;Notation&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;${\rm CH(Q)}$ represents convex hull&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;grahams-scan-onlg-n&quot;&gt;Graham’s Scan $O(n\lg n)$&lt;/h1&gt;

&lt;p&gt;It solves convex-hull problem by maintaining a stack $S$ of candidate points. It pushes each point of the input set $Q$ onto the stack one time, and it eventually pops from the stack each point that is not a vertex of ${\rm CH}(Q)$.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$p_0$ is the point in $Q$ with th eminimum $y$-coordinate (leftmost in case of tie)&lt;/li&gt;
  &lt;li&gt;$\langle p_1, p_2,…p_m\rangle$ remaining points in $Q$ sorted by polar angle in counterclockwise order around $p_0$, (take farthest in case of tie.)&lt;/li&gt;
  &lt;li&gt;$S=\langle p_0, p_1, p_2\rangle$ (pop from right side, $p_2$ first)&lt;/li&gt;
  &lt;li&gt;For point $p_i=p_3$ to $p_m$
    &lt;ul&gt;
      &lt;li&gt;While angle formed by points second and first element of $S$ make a nonleft turn: Remove top elemnt.&lt;/li&gt;
      &lt;li&gt;push $p_i$ to $S$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Finally, $S={\rm CH(Q)}$&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;jarvis-march-onh&quot;&gt;Jarvis’ March $O(nh)$&lt;/h1&gt;

&lt;p&gt;[Here $h$ is the number of vertices in ${\rm CH(Q)}$, where $h$ is $o(\lg n)$]&lt;/p&gt;

&lt;p&gt;We start from lowest point $p_0$ and take the point with smallest polar angle wrt $p_1$. Then we take $p_2$ with the smallest poisitive angle wrt $p_1$ and so on until we reach the highest point $p_k$, then we do the same but we calculate the angle from negative x-axis. Finally we reach back at $p_0$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://adityagupta1089.github.io/images/jarvis.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 01 Nov 2019 14:42:00 +0000</pubDate>
        <link>https://adityagupta1089.github.io/notes/algorithms/convex-hull.html</link>
        <guid isPermaLink="true">https://adityagupta1089.github.io/notes/algorithms/convex-hull.html</guid>
        
        
        <category>Notes</category>
        
        <category>Algorithms</category>
        
      </item>
    
      <item>
        <title>Chess &amp; Space</title>
        <description>&lt;h1 id=&quot;the-third-principle-space&quot;&gt;The Third Principle: Space&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;When you have advantage in space, you control more trritory than your opponent&lt;/li&gt;
  &lt;li&gt;Your pieces have more sqaures to choose from than the enemy pieces, which are severely restricted in their movements.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-space-count-system&quot;&gt;The Space Count System&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;White owns the ranks from 1 to 4, while black owns the ranks from 5 to 8.&lt;/li&gt;
  &lt;li&gt;Anything controlled beyond these personal squares in the enemey domain is accounted in space count system.&lt;/li&gt;
  &lt;li&gt;Other factors to consider are:
    &lt;ul&gt;
      &lt;li&gt;Can king castle?&lt;/li&gt;
      &lt;li&gt;Pawn/Piece advantage&lt;/li&gt;
      &lt;li&gt;Pawn islands?&lt;/li&gt;
      &lt;li&gt;Rook on active files&lt;/li&gt;
      &lt;li&gt;etc.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;how-to-use-a-space-advantage&quot;&gt;How to use a space advantage&lt;/h2&gt;

&lt;h3 id=&quot;rooks-and-open-files&quot;&gt;Rooks and Open Files&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Rooks need open files to be effective.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bishops-and-open-diagonals&quot;&gt;Bishops and Open Diagonals&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Bishops need open diagonals if they are to reach their full potential.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;the-fianchettoed-bishop&quot;&gt;The Fianchettoed Bishop&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;To place a bishop on the longest possible diagona is to fianchetto it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;the-knight-as-advance-scout&quot;&gt;The Knight as Advance Scout&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Don’t keep knight in corner and try to advance knight for more space.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;how-to-gain-a-space-advantage-in-the-openeing&quot;&gt;How to gain a space advantage in the openeing&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Acquiring superior force in some part of the board&lt;/li&gt;
  &lt;li&gt;Gaining a lead in development&lt;/li&gt;
  &lt;li&gt;Improving your paawn structure&lt;/li&gt;
  &lt;li&gt;Gaining space&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;how-to-defend-against-a-space-advantage&quot;&gt;How to defend against a space advantage&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;The player with less space should try to trade some pieces.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 31 Oct 2019 18:31:00 +0000</pubDate>
        <link>https://adityagupta1089.github.io/chess/notes/chess-space.html</link>
        <guid isPermaLink="true">https://adityagupta1089.github.io/chess/notes/chess-space.html</guid>
        
        
        <category>Chess</category>
        
        <category>Notes</category>
        
      </item>
    
      <item>
        <title>Chess &amp; Time</title>
        <description>&lt;h1 id=&quot;the-second-principle-time&quot;&gt;The Second Principle: Time&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Focus on developing pieces and try to avoid moving a single piece twice&lt;/li&gt;
  &lt;li&gt;Try not developing queen early in the game.&lt;/li&gt;
  &lt;li&gt;Try to develop minor pieces then queen, castle and then attack.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;going-for-a-gambit&quot;&gt;Going for a Gambit&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Gambit is a voluntary sacrifice of a piece or pawn in the opening with the idea of a lead in development and subsequent attack as compensation.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 31 Oct 2019 17:29:00 +0000</pubDate>
        <link>https://adityagupta1089.github.io/chess/notes/chess-time.html</link>
        <guid isPermaLink="true">https://adityagupta1089.github.io/chess/notes/chess-time.html</guid>
        
        
        <category>Chess</category>
        
        <category>Notes</category>
        
      </item>
    
      <item>
        <title>String Matching</title>
        <description>&lt;h1 id=&quot;formalization&quot;&gt;Formalization:&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Text: $T[1..n]$&lt;/li&gt;
  &lt;li&gt;Pattern: $P[1..m]$ ($m\le n$)&lt;/li&gt;
  &lt;li&gt;elements of $P$ and $T$ are characters drawn from a finite alphabet $\Sigma$.&lt;/li&gt;
  &lt;li&gt;$\Sigma^*$ denotes the set of all finite-length string using $\Sigma$&lt;/li&gt;
  &lt;li&gt;$\varepsilon\in \Sigma ^*$ emptry string&lt;/li&gt;
  &lt;li&gt;$x y$ denotes concatenation of $x$ and $y$&lt;/li&gt;
  &lt;li&gt;$w\sqsubset x$: $w$ is a prefix of $x$, i.e. $x=wy$ for some $y\in \Sigma^*$&lt;/li&gt;
  &lt;li&gt;$w\sqsupset x$: $w$ is a suffix of $x$, i.e. $x=yw$ for some $y\in \Sigma^*$&lt;/li&gt;
  &lt;li&gt;$P_k$ is the $k$-character prefix $P[q..k]$&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;comparison-of-algorithms&quot;&gt;Comparison of Algorithms:&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Algorithm&lt;/th&gt;
      &lt;th&gt;Preprocessing time&lt;/th&gt;
      &lt;th&gt;Matching Time&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Naive&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;$O((n-m+1)m)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Rabin-Karp&lt;/td&gt;
      &lt;td&gt;$\Theta(m)$&lt;/td&gt;
      &lt;td&gt;$O((n-m+1)m)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Finite Automaton&lt;/td&gt;
      &lt;td&gt;$O(m\vert \Sigma\vert)$&lt;/td&gt;
      &lt;td&gt;$\Theta(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Knuth-Morris-Pratt&lt;/td&gt;
      &lt;td&gt;$\Theta(m)$&lt;/td&gt;
      &lt;td&gt;$\Theta(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Z-Algorithm&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;$\Theta(m+n)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;rabin-karp-algorithm&quot;&gt;Rabin-Karp algorithm&lt;/h1&gt;
&lt;p&gt;Based on certain assumptions its average-case running time is better.&lt;/p&gt;

&lt;p&gt;Let us assume $\Sigma={0,1,2,\ldots,d}$. Let $p$ denote the interpretation of $P[1..m]$ as a radix-d number. Similarly let $t_s$ denote the interpretatin of $T[s+1\ldots s+m]$ for $s\in {0,1,\dots n-m}$. Now $t_s=p\iff T[s+1\ldots s+m]=P[1..m]$.&lt;/p&gt;

&lt;p&gt;We can compute $p$ in $\Theta(m)$ using Horner’s rule&lt;/p&gt;

&lt;p&gt;$p=P[m]+10(P[m-1]+10(P[m-2]+\ldots))$&lt;/p&gt;

&lt;p&gt;Similarly&lt;/p&gt;

&lt;p&gt;$t_{s+1}=10(t_s-10^{m-1}T[s+1])+T[s+m+1]$&lt;/p&gt;

&lt;p&gt;where we can calculate $10^{m-1}$ in $O(\lg m)$.&lt;/p&gt;

&lt;p&gt;For string matching we work with $\mathbb Z_q$ where $q$ is a prime such that $dq$ fits inside a computer word. However $t_{s} \equiv p\pmod q$ doesn’t imply that $t_s=p$, but $t_s\not\equiv p\mod q\implies t_s\neq p$. So we additionaly check explicity string equality.&lt;/p&gt;

&lt;p&gt;In worst case it could be $\Theta((n-m+1)m)$ when all shifts are valid.&lt;/p&gt;

&lt;p&gt;In average case we expect only $c$ shifts to be valid, then matching time is $O((n-m+1)+cm)=O(n+m)$ plus time required to process spurious hits. We can expect the number of spurious hits to be $O(n/q)$ since $t_s\equiv p\pmod q$ with probability $1/q$. This makes the expected matching time to be $O(n)+O(m(\nu+n/q))$ where $\nu$ is number of valid shifts. This is $O(n)$ if $\nu=O(1)$ (expected number of valid shifts is small) and $q\ge m$ ($q$ larger than the length of pattern)&lt;/p&gt;

&lt;h1 id=&quot;finite-automata&quot;&gt;Finite Automata&lt;/h1&gt;

&lt;h2 id=&quot;definition&quot;&gt;Definition&lt;/h2&gt;

&lt;p&gt;A finite automaton $M(Q, q_0, A, \Sigma, \delta)$ where&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$Q$: states,&lt;/li&gt;
  &lt;li&gt;$q_0\in Q$: start state,&lt;/li&gt;
  &lt;li&gt;$A\subseteq Q$: accepting states,&lt;/li&gt;
  &lt;li&gt;$\Sigma$: input alphabet&lt;/li&gt;
  &lt;li&gt;$\delta:Q\times \Sigma\mapsto Q$: transition function&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$M$ induces a function $\phi:\Sigma^*\mapsto Q$ (final-state function) such that $\phi(w)$ is the state $M$ ends up in after scanning the string $w$. $M$ accepts a string $w$ iff $\phi(w)\in A$.&lt;/p&gt;

&lt;p&gt;$\phi(\varepsilon)=q_0$&lt;/p&gt;

&lt;p&gt;$\phi(wa)=\delta(\phi(w), a)\text{ for }w\in\Sigma^*, a\in \Sigma$&lt;/p&gt;

&lt;h2 id=&quot;string-matching-automata&quot;&gt;String-matching automata&lt;/h2&gt;

&lt;p&gt;For $P$ we generate a string-matching automaton in a preprocessing step.&lt;/p&gt;

&lt;p&gt;For this we define an auxilary function $\sigma:\Sigma^*\mapsto{0,1,\ldots,m}$, the suffix function corresponding to $P$. $\sigma(x)$ is the length of the longest prefix of $P$ that is also a suffix of $x$.&lt;/p&gt;

&lt;p&gt;$\sigma(x)=\max{k: P_k \sqsupset x}$&lt;/p&gt;

&lt;p&gt;We have $\sigma(x)=m\iff P\sqsupset x$, also $x\sqsubset y\implies \sigma(x)\le \sigma(y)$ from definition.&lt;/p&gt;

&lt;p&gt;We define &lt;strong&gt;string-matching automaton&lt;/strong&gt; as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$Q={0,1,\ldots,m}$, $q_0=0$, $A={m}$&lt;/li&gt;
  &lt;li&gt;$\delta(q, a)=\sigma(P_qa)$ is the longest prefix of pattern $P$ that has matched the text string $T$ so far.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We consider most recently read characters of $T$. For $T_i=P_j$, $P_j\sqsupset T_i$.&lt;/p&gt;

&lt;p&gt;Let $q=\phi(T_i)$. We design $\delta$ such that at $q$, $P_q\sqsupset T_i$ and $q=\sigma(T_i)$. Therefore $\phi(T_i)=\sigma(T_i)$.&lt;/p&gt;

&lt;p&gt;If the automaton is in state $q$ and reads the next characters $T[i+1]=a$, then we want the transition to lead to the state corresponding to the longest prefix of $P$ that is a suffix of $T_ia$, i.e. $\sigma(T_ia)$.&lt;/p&gt;

&lt;p&gt;Because $P_q$ is the longest prefix of $P$ that is a suffix of $T_i$ , i.e. $P_q=\sigma(T_i)$ we also have the longest prefix of $P$ that is a suffix of $T_ia$ is not only $\sigma(T_ia)$ but also $\sigma(P_qa)$.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If $a=P[q+1]$, $\delta(q, a)=q+1$.&lt;/li&gt;
  &lt;li&gt;If $a\neq P[q+1]$ we find a smaller prefix of $P$ that is also a suffix of $T_i$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;kunth-morris-pratt-algorithm&quot;&gt;Kunth-Morris-Pratt Algorithm&lt;/h1&gt;

&lt;p&gt;Given a pattern $P[1..m]$, the &lt;strong&gt;prefix function&lt;/strong&gt; for the pattern $P$ is the function $\pi:{1,2,\ldots, m}\mapsto{0,1,\ldots, m-1}$ such that&lt;/p&gt;

&lt;p&gt;$\pi[q]=\max{k:k&amp;lt;q\wedge P_k\sqsupset P_q}$&lt;/p&gt;

&lt;p&gt;i.e. $\pi[q]$ is the length of the longest prefix of $P$ that is a proper suffix of $P_q$.&lt;/p&gt;

&lt;p&gt;For matching:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Scan the text $T$ from left to right starting with $q=0$ (number of characters matched is $0$ initially):
    &lt;ul&gt;
      &lt;li&gt;While $q&amp;gt;0$ and next character doesn’t match, i.e. $P[q+1]\neq T[i]$, keep doing $q\leftarrow\pi[q]$&lt;/li&gt;
      &lt;li&gt;If next character matches, i.e. $P[q+1]=T[i]$, then $q\leftarrow q+1$&lt;/li&gt;
      &lt;li&gt;If $q=m$, pattern is found, and set $q\leftarrow\pi[q]$
        &lt;pre&gt;&lt;code class=&quot;language-pseudocode&quot;&gt;  q = 0
  for i = 0 to n - 1:
  	while (k &amp;gt; 0 &amp;amp;&amp;amp; T[i] != P[q]):
  		q = pi[q-1]
  	if (T[i] == P[q]):
  		q++
  	if (q == m):
  		# Pattern Found
  		q = pi[q - 1]
  	pi[q] = k
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For computing prefix-function:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$\pi[1]\leftarrow0$ by definition&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scan the pattern $P$ from left to right starting from $q=2$ 2 (loop starts from 2nd character, 1-indexed) and $k=0$ (number of characters matched in 0 initially):&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;While $k&amp;gt;0$ and next character doesn’t match, i.e. $P[k+1]\ne P[q]$, keep doing $k\leftarrow\pi[k]$&lt;/li&gt;
      &lt;li&gt;If next character matches, i.e. $P[k+1]=P[q]$, then $k\leftarrow k+1$.&lt;/li&gt;
      &lt;li&gt;Set $\pi[q]\leftarrow k$&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-pseudocode&quot;&gt;  pi[1] = 0
  k = 0
  for q = 1 to m - 1:
  	while (k &amp;gt; 0 &amp;amp;&amp;amp; P[k] != P[q]):
  		k = pi[k-1]
  	if (P[k] == P[q]):
  		k++
  	pi[q] = k
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;z-algorithm&quot;&gt;Z-Algorithm&lt;/h1&gt;

&lt;p&gt;The algorithm produces an array $Z$  where $Z[i]$ denotes the length of the longest substring starting from $S[i]$ which is also a prefix of $S$. We refer to prefix-substrings as substrings which are also prefix.&lt;/p&gt;

&lt;p&gt;As we iterate over the letters in the string we maintain an interval $[L, R]$ which is the interval with maximum $R$ such that $1\le L\le i\le R$ and $S[L\ldots R]$is a prefix-substring (if no such inteval exists $L=R=-1$)&lt;/p&gt;

&lt;p&gt;Now suppose we have correct interval $[L, R]$ for $i-1$ and for all values of $Z$ upto $i-1$, we will compute  $Z[i]$ and new $[L, R]$ by following steps:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$i&amp;gt;R$:
    &lt;ul&gt;
      &lt;li&gt;there is not a prefix-substring of $S$ that starts before $i$ and ends at $\ge i$. We would have taken that interval instead.&lt;/li&gt;
      &lt;li&gt;Set $[L,R]$ to $[i,i]$ and start comparing $S[0…]$ to $S[i…]$ and $Z[i]=R-L+1$.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;$i\le R$:
    &lt;ul&gt;
      &lt;li&gt;Let $k=i-L$. We know that $Z[i]\ge \min (Z[k], R-i+1)$&lt;/li&gt;
      &lt;li&gt;$Z[k]&amp;lt;R-i+1$:
        &lt;ul&gt;
          &lt;li&gt;$Z[i]=Z[k]$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;$Z[k]\ge R-i+1$:
        &lt;ul&gt;
          &lt;li&gt;Update $[L,R]$ to $[i,R]$ and start comparing $S[R+1…]$ to $S[k+1…]$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-pseudocode&quot;&gt;  L = 0
  R = 0
  for i = 1 to n:
  	if (i &amp;gt; R):
  		L = i
  		R = i
  		while (R &amp;lt; n &amp;amp;&amp;amp; s[R - L] == s[R]):
  			R++
  		Z[i] = R - L
  		R--
  	else:
  		k = i - L
  		if (Z[k] &amp;lt; R - i + 1):
  			Z[i] = Z[k]
  		else:
  			L = i
  			while (R &amp;lt; n &amp;amp;&amp;amp; s[R-L] == s[R]):
  				R++
  			Z[i] = R - L
  			R--
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For pattern matching we use Z-algorithm on string $P\Phi T$ where $\Phi$ matches nothing Then indices with $Z[i]=m$ correspond to matches in $T$ of $P$.&lt;/p&gt;

</description>
        <pubDate>Wed, 30 Oct 2019 19:12:00 +0000</pubDate>
        <link>https://adityagupta1089.github.io/notes/algorithms/string-matching.html</link>
        <guid isPermaLink="true">https://adityagupta1089.github.io/notes/algorithms/string-matching.html</guid>
        
        
        <category>Notes</category>
        
        <category>Algorithms</category>
        
      </item>
    
      <item>
        <title>Splay Trees</title>
        <description>&lt;p&gt;Self-adjusting binary trees that work in $O(\log n)$ amortized time bound. The operation performed is the &lt;em&gt;splay&lt;/em&gt; operation.&lt;/p&gt;

&lt;p&gt;For a splay operation at node x: ($p(x)$ is the parent of $x$)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Case (a):&lt;/strong&gt; If $x$ has a parent but no grandparent we rotate at $p(x)$.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Case (b):&lt;/strong&gt; If $x$ has a grandparent and both $x$ and $p(x)$ are both left or right childrenn, we rotate at $p^2(x)$ and then at $p(x)$.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Case (c):&lt;/strong&gt; If $x$ has a grandparent and $x$ is a left and $p(x)$ is a right child, or vice versa, we rotate at $p(x)$ and then at the new parent of $x$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://adityagupta1089.github.io/images/splaytree1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This moves $x$ to the root of the tree while rearranging the rest of the original path to $x$.&lt;/p&gt;

&lt;p&gt;We perform a splay operation during each access or update operation. Using amortized time analysis for $m$ operations total time taken is $O(m\log n)$ or $O(\log n)$ amortized time per operation.&lt;/p&gt;

&lt;h1 id=&quot;amortized-time-analysis&quot;&gt;Amortized Time Analysis&lt;/h1&gt;

&lt;p&gt;Let $T$ be a tree of $n$ nodes. For node $v\in T$ let $n_T(v)$ ve the number of nodes in the subtree of $v$ including $v$.&lt;/p&gt;

&lt;p&gt;We define the potential function $\phi(T)=\sum_{v\in T}r_T(v)$ where $r_{T}(v)=\log &lt;em&gt;{2}\lfloor n&lt;/em&gt;{T}(v)\rfloor$.&lt;/p&gt;

&lt;p&gt;For a completely skewed tree it will be $\log_2n+\log_2(n-1)+\ldots \log_21=O(n\log n)$.&lt;/p&gt;

&lt;p&gt;For a completely balanced tree of height $h$ it will be $\sum_{i=0}^h2^i\log_2(2^{h-i+1})=\sum_{i=0}^h2^i(h-i+1)=O(n)$&lt;/p&gt;

&lt;p&gt;Suppose the tree undergoes $m$ searches for keys $k_{i_1},k_{i_2},\ldots k_{i_m}$ starting from tree $T_0$ and after searching for $k_{i_1}$ to $T_1$ and so on until $T_m$.&lt;/p&gt;

&lt;p&gt;Let actual cost of $i^{\rm th}$ search be $c_i$ and amortized cost of $i^{\rm th}$ search be $\hat c_i=c_i+\phi(T_i)-\phi(T_{i-1})$. We claim that $\hat{c}_{i} \leqslant 3 \log _{2} n$. Hence actual cost becomes
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
\sum_{i=1}^mc_i&amp;=\sum_{i=1}^m[\hat c_i+\phi(T_{i-1})-\phi(T_i)]\\
&amp;=\sum_{i=1}^m\hat c_i+\sum_{i=1}^m(\phi(T_{i-1}-\phi(T_i)))\\
&amp;=\sum_{i=1}^m\hat c_i+[\phi(T_0)-\phi(T_m)]\\
&amp;=\sum_{i=1}^m\hat c_i+n\log n\\
&amp;\le3m\log n+n\log n\\
&amp;\le 4m\log n\tag{$m\ge n$}
\end{align} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Now we prove $\hat{c}_{i} \leqslant 3 \log _{2} n$ for various cases. $r’$ represents the rank after rotation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lemma&lt;/strong&gt; If $a+b\le c$ then $\log a+\log b\le 2\log c-2$ since $ab\le c^2/4$  where $c^2\ge (a+b)^2\ge 4ab$ using AM-GM inequality.&lt;/p&gt;

&lt;h2 id=&quot;case-a-zig&quot;&gt;Case (a) (zig)&lt;/h2&gt;

&lt;p&gt;Total cost involves 1 rotation and potential change. We have $r’(x)=r(y)$ so $\Delta \phi=(r’(x)+r’(y))-(r(x)+r(y))=r’(y)-r(x)\le r’(x)-r(x)$ as $y$ has less nodes afterwards and less rank. So $\hat c_i\le 1+(r’(x)-r(x))\le 1+3(r’(x)-r(x))$&lt;/p&gt;

&lt;h2 id=&quot;case-c-zig-zag&quot;&gt;Case (c) (zig-zag)&lt;/h2&gt;

&lt;p&gt;Total cost involves 2 rotation and potential change $\Delta \phi=r’(x)+r’(y)+r’(z)-r(x)-r(y)-r(z)$&lt;/p&gt;

&lt;p&gt;Here $\hat c_i=2+(r’(x)-r(x))+r’(y)+r’(z)-r(y)-r(z)$&lt;/p&gt;

&lt;p&gt;Also $n’(y)+n’(z)= n’(x)-1\le n’(x)$. Using the lemma $\log (n’(y)) + \log (n’(z))\le 2\log (n’(x))-2$ or $r’(y)+r’(z)\le 2r’(x)-2$.&lt;/p&gt;

&lt;p&gt;So we have $\hat c_i\le 2+ (r’(x)-r(x))+(2r’(x)-2)-r(y)-r(z)$ or $\hat c_i\le (3r’(x)-r(x)-r(y)-r(z)$. Also we have $r(z)=r(x)$ and $r(y)\ge  r(x)$ so $\hat c_i\le 3(r’(x)-r(x))$&lt;/p&gt;

&lt;h2 id=&quot;case-b-zig-zig&quot;&gt;Case (b) (zig-zig)&lt;/h2&gt;

&lt;p&gt;Total cost involves 2 rotation and potential change&lt;/p&gt;

&lt;p&gt;Similar to &lt;strong&gt;case (c)&lt;/strong&gt; we have $\hat c_i=2+(r’(x)-r(x))+r’(y)+r’(z)-r(y)-r(z)$ and $n(x)+n’(z)+1=n’(x)$ giving $r(x)+r’(z)\le 2r’(x)-2$ or $r’(z)\le 2r’(x)-r(x)-2$&lt;/p&gt;

&lt;p&gt;So we have $\hat c_i\le 2+(r’(x)-r(x))+r’(y)+(2r’(x)-r(x)-2)-r(y)-r(z)$ or $\hat c_i\le (3r’(x)-2r(x))+r’(y)-r(y)-r(z)$. Also we have $r(z)=r’(x)$ and  $r(y)\ge r(x) $ giving $\hat c_i\le 3(r’(x)-r(x))-\underbrace{(r(z)-r’(y))}_{&amp;gt;0}\ge 3(r’(x)-r(x))$&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If we have $d$ splays then $\hat c=\sum_{i=1}^d\hat c_i\le \sum_{i=1}^d3(r_i(x)-r_{i-1}(x))=3(r_d(x)-r_0(x))$&lt;/p&gt;

&lt;p&gt;The maximum change in rank can be $\log n$ giving $\hat c\le 3\log n$&lt;/p&gt;

</description>
        <pubDate>Tue, 29 Oct 2019 18:42:00 +0000</pubDate>
        <link>https://adityagupta1089.github.io/notes/data%20structures/splay-trees.html</link>
        <guid isPermaLink="true">https://adityagupta1089.github.io/notes/data%20structures/splay-trees.html</guid>
        
        
        <category>Notes</category>
        
        <category>Data Structures</category>
        
      </item>
    
      <item>
        <title>Fast Fourier Transform</title>
        <description>&lt;h1 id=&quot;motivation&quot;&gt;Motivation&lt;/h1&gt;

&lt;p&gt;The product of two $d$-degree polynomials is a polynomial of degree $2d$, i.e. if $A(x)=a_0+a_1x+a_2x^2+\ldots+a_dx^d$ and $B(x)=b_0+b_1+b_2x^2+\ldots+b_dx^d$ then&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A(x)B(x)=a_0b_k+a_1b_{k-1}+\ldots+a_kb_0=\sum_{i=0}^{k}a_i b_{k-i}&lt;/script&gt;

&lt;p&gt;Computing $c_k$ from this formula takes $O(k)$ steps aand finding all $2d+1$ coefficients would therefore take $\Theta(d^2)$&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A degree-$d$ polynomial is uniquely characterized by its values at any $d+1$ distinct points.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can represent a degree-$d$ polynomial $A(x)$ by either (i) it’s coefficients $a_0, a_1,\ldots a_d$ or (ii) the values $A(x_0), A(x_1),\ldots A(x_d)$&lt;/p&gt;

&lt;p&gt;In the second representation polynomial multiplication takes linear time.&lt;/p&gt;

&lt;h1 id=&quot;evaluation-by-divide-and-conquer&quot;&gt;Evaluation by divide-and-conquer&lt;/h1&gt;

&lt;p&gt;If we choose the $n$ points for evaluation of $A(x)$ as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\pm x_0, \pm x_1, \ldots, \pm x_{n/2-1}&lt;/script&gt;

&lt;p&gt;then the computatin required for each $A(x_i)$ and $A(-x_i)$ overlap a lot because the even powers of $x_i$ coincide with those of $-x_i$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A(x)=(a_0+a_2x^2+a_4x^4+\ldots)+x(a_1+a_3x^2+\ldots)
A(x)=A_{\rm even}(x^2)+xA_{\rm odd}(x^2)&lt;/script&gt;

&lt;p&gt;hence&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A(x_i)=A_e(x_i^2)+x_iA_o(x_i^2)
A(-x_i)=A_e(x_i^2)-x_iA_o(x_i^2)&lt;/script&gt;

&lt;p&gt;Noew we need to evaluate $A_e(x)$ and $A_o(x)$ (which each have half the degree of $A(x)$) at just $n/2$ points, $x_0^2,\ldots x_{n/2-1}^2$.&lt;/p&gt;

&lt;p&gt;If we could recurse then time complexity would be $T(n)=2T(n/2)+O(n)\implies O(n\log n)$. The plus-minus trick only works at the top level of the recursion. To recurse at the next level, we need the $n/2$ evaluation points $x_0^2, x_1^2,\ldots x_{n/2-1}^2$ to be themselves plus-minus pairs. For this we take $n^{\rm th}$ roots of unity as the evaluation points.&lt;/p&gt;

&lt;h1 id=&quot;interpolation&quot;&gt;Interpolation&lt;/h1&gt;

&lt;p&gt;We have $\rm \langle values\rangle = FFT(\langle coefficients\rangle, \omega)$. where the complex roots of unity are ${1,\omega,\omega^2,\ldots,\omega^{n-1}}$&lt;/p&gt;

&lt;p&gt;We have:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://adityagupta1089.github.io/images/fft1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Call the matrix in the middle $M$. Its specialized format - a &lt;em&gt;Vandermonde&lt;/em&gt; matrix gives its many remarkable properties&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If $x_0, \ldots x_{n-1}$ are distinct numbers, then $M$ is invertible. Vandermonde matrices are quicker to invert than more general matrices in $O(n^2)$ instead of $O(n^3)$. However, this is still not fast enough so we turn to complex roots of unity.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;interpolation-resolved&quot;&gt;Interpolation resolved&lt;/h2&gt;

&lt;p&gt;The FFT multiplies an arbitary $n$-dimensional vector (&lt;em&gt;coefficient representation&lt;/em&gt;) by the $n\times n$ matrix&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://adityagupta1089.github.io/images/fft2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It’s $(j,k)^{\rm th}$ entry is $\omega^{jk}$. The columns of $M$ are orthogonal to each other and are called &lt;em&gt;Fourier basis&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Take $\omega=e^{2\pi i/n}$ and $\langle u, v\rangle = u_0\overline{v_0}+u_1\overline{v_1}+\ldots u_{n-1}\overline{v_{n-1}}$ where $\overline {re^{i\theta}}=re^{-i\theta}$.&lt;/p&gt;

&lt;p&gt;Multiplication of columns $j$ and $k$ of matrix $M$ gives&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;1+\omega^{j-k}+\omega^{2(j-k)}+\ldots+\omega^{(n-1)(j-k)}=\frac{(1-\omega^{n(j-k)})}{(1-\omega^{j-k})}&lt;/script&gt;

&lt;p&gt;which is a Geometric series which is $0$  except $j=k$ in which case all terms are $1$ and sum is $n$.&lt;/p&gt;

&lt;p&gt;Thus $M\overline {M}=nI$ or $M^{-1}=\frac 1n\overline {M}$. The $(j, k)^{\rm th}$ entry of $\overline M$ is the complex conjugate of the correspoding entry of $M$, i.e. $\omega ^{-jk}$. So $\overline {M}=M_n(\omega^{-1})$&lt;/p&gt;

&lt;p&gt;So we have $ \langle {\rm coefficient}\rangle = \frac 1n \rm FFT(\langle values\rangle, \omega^{-1})$&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
        <link>https://adityagupta1089.github.io/notes/algorithms/fast-fourier-transform.html</link>
        <guid isPermaLink="true">https://adityagupta1089.github.io/notes/algorithms/fast-fourier-transform.html</guid>
        
        
        <category>Notes</category>
        
        <category>Algorithms</category>
        
      </item>
    
      <item>
        <title>Chess &amp; Force</title>
        <description>&lt;h1 id=&quot;the-first-principle-force&quot;&gt;The First Principle: Force&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Try to have more pieces overall. (Use piece values)&lt;/li&gt;
  &lt;li&gt;Try to have more pieces ina particular area of the board.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;basic-tactics&quot;&gt;Basic Tactics&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;The Pin - prevent enemy piece from moving&lt;/li&gt;
  &lt;li&gt;The Fork - simultaneous attack on two or more pieces&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;laying-traps&quot;&gt;Laying Traps&lt;/h2&gt;
&lt;h3 id=&quot;a-pair-of-weaklings&quot;&gt;A Pair of Weaklings&lt;/h3&gt;

&lt;p&gt;This type of trap is based on the weakness of the pawns on squares f7 and f2.&lt;/p&gt;

&lt;div class=&quot;chess&quot;&gt;
[Title &quot;Scholar's Mate&quot;]

1. e4 e5
2. Bc4 Nc6
3. Qh5 Nf6??
4. Qxf7#
&lt;/div&gt;

&lt;div class=&quot;chess&quot;&gt;
[Title &quot;Legall's Mate&quot;]

1. e4 e5
2. Nf3 d6
3. Nc3 g6
4. Bc4 Bg4?
{Black has tied down White's Knight on f3 with a pin. However, his Bishop is undefended on g4 and White's army is better developed. White can now launch a surprise attack against square f7.}
5. Nxe5!!
{Black should now limit his losses and play 5...dxe5 which White would respond with 6.Qxg4. However, instead of losing a pawn, Black eats White's Queen} Bxd1?
{So Black captures a Queen. But now Black's pawn on f7 falls and White's attack crashes through}
6. Bxf7+ Ke7
7. Nd5#
&lt;/div&gt;

&lt;h3 id=&quot;the-case-of-undefended-piece-discovery-attack&quot;&gt;The Case of Undefended Piece (discovery attack)&lt;/h3&gt;

&lt;p&gt;Discovered attacks are usually directed at undefended pieces.&lt;/p&gt;

&lt;div class=&quot;chess&quot;&gt;
[Title &quot;The Excommunicated Bishop&quot;]

1. e4 e5 2. Nf3 d6 3. Bc4 Nc6 4. Nc3 Bg4 5. O-O {The Legall's Mate move 5.Nxe5, would not work here because Black can play 5...Nxe5! to prevent the checkmate and defend the Bishop on g4} Nge7?? {He would do better to play 5...Nf6 simply defending the Bhisop on g4} 6. Bxf7+ Kxf7 7. Ng5+ {The knight checks, thereby uncovering a Queen attack on the Black Bishop} Ke8 8. Qxg4
&lt;/div&gt;

&lt;div class=&quot;chess&quot;&gt;
[Title &quot;The Queen That Never Came Home&quot;]

1. e4 d5 2. exd5 Qxd5 3. Nc3 Qd8 4. d4 e6 5. Bd3 Qxd4?? {Black thinks that White has overlooked a pawn but a surprise is in store} 6. Bb5+!
&lt;/div&gt;

&lt;h3 id=&quot;the-battering-ram&quot;&gt;The Battering Ram&lt;/h3&gt;

&lt;p&gt;This type of trap is based on dimantling the enemy king’s cover.&lt;/p&gt;

&lt;div class=&quot;chess&quot;&gt;
[Title &quot;Fool's Mate&quot;]

1. f4 {This move is called the &lt;i&gt;Bird Opening&lt;/i&gt;} e6
2. g4?? {For no reason whatsoever White has opened up his own King to attack on the e1-h4 diagonal} Qh4#
(1...e5 2.fxe5 {With this second move, White avoids g3 leading to checkmate} (2. g3 exf4 3. gxf4?? Qh4#) d6 {Black is not tempted by Qh4+ which would be adequately countered by g3 when Black's Queen must retreat} (2...Qh4+ 3.g3) 3. exd6 Bxd6 {Black has sacrificed a pawn so that he can obtain a lead in development. This type of deliberate sacrifice in the opening is called a &lt;i&gt;gambit&lt;/i&gt;} 4. Nc3?? {Oops White didn't see the threat. He should have played Nf4 which would develop a piece and prevent ...Qh4+} Qh4+ 5. g3 Qxg3+!! 6. hxg3 Bxg3#)
&lt;/div&gt;

&lt;div class=&quot;chess&quot;&gt;
[Title &quot;The Cheap Check&quot;]

1. e4 c6 2. d4 d5 3. Nc3 dxe4 4. Nxe4 Nd7 5. Qe2 Ngf6 6. Nd6#
&lt;/div&gt;

&lt;h2 id=&quot;king-plays-in-the-endgame&quot;&gt;King Plays in the endgame&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;king is a powerful piece and should be brought out into the play in the endgame.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;endgames&quot;&gt;Endgames&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;King &amp;amp; Queen vs. King - trapping in a box&lt;/li&gt;
  &lt;li&gt;King &amp;amp; Rook vs. King - move king as close to enemy king and then use rook&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;preference-or-principle&quot;&gt;Preference or Principle&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Do not take pieces directly for their piece values.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;when-less-is-more&quot;&gt;When less is more&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Weaker pieces may be stronger in certain situations.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 28 Oct 2019 16:01:00 +0000</pubDate>
        <link>https://adityagupta1089.github.io/chess/notes/chess-force.html</link>
        <guid isPermaLink="true">https://adityagupta1089.github.io/chess/notes/chess-force.html</guid>
        
        
        <category>Chess</category>
        
        <category>Notes</category>
        
      </item>
    
      <item>
        <title>Bobby Fischer Teaches Chess (Back-Rank Mating)</title>
        <description>&lt;p&gt;This book talks about&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Introduction: How to play chess
    &lt;ul&gt;
      &lt;li&gt;Description of the Board &amp;amp; Pieces&lt;/li&gt;
      &lt;li&gt;Moving &amp;amp; Capturing&lt;/li&gt;
      &lt;li&gt;Special Moves: Castling, Pawn Promotion, Capturing En Passant&lt;/li&gt;
      &lt;li&gt;Piece Values: Pawn(1), Knight(3), Bishop(3.25), Rook(5), Queen(9), King(Infinity)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Chapter 1: Elements of Checkmate
    &lt;ul&gt;
      &lt;li&gt;Conditions of checkmate&lt;/li&gt;
      &lt;li&gt;Defenses: capturing, fleeing, interposing&lt;/li&gt;
      &lt;li&gt;Pins&lt;/li&gt;
      &lt;li&gt;Discovered checks&lt;/li&gt;
      &lt;li&gt;Mate in 1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Chapter 2: Back-Rank Mates
    &lt;ul&gt;
      &lt;li&gt;Useful/Useless Interposition&lt;/li&gt;
      &lt;li&gt;Amount of power needed to mate&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Chapter 3: Back-Rank Defenses and Variations
    &lt;ul&gt;
      &lt;li&gt;Removing/Capturing the defenders&lt;/li&gt;
      &lt;li&gt;disconnected rooks&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;https://adityagupta1089.github.io/images/fischer1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;sideways back-rank&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Chapter 4: Displacing Defenders
    &lt;ul&gt;
      &lt;li&gt;Drawing away defenders&lt;/li&gt;
      &lt;li&gt;Displacing the king&lt;/li&gt;
      &lt;li&gt;Displacing the king in 2 moves&lt;/li&gt;
      &lt;li&gt;Defense against displacement of king in 2 Moves&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Chapter 5: Attacks on the enemy pawn cover
    &lt;ul&gt;
      &lt;li&gt;Sacrifice leading to mate&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;chapter-6-final-review&quot;&gt;Chapter 6: &lt;strong&gt;Final Review&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&quot;mating-themes&quot;&gt;Mating Themes&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Elementary back-rank mate&lt;/li&gt;
  &lt;li&gt;Back-rank combination (more power)&lt;/li&gt;
  &lt;li&gt;Eliminating a back-rank defender, enemy recaptures using&lt;/li&gt;
  &lt;li&gt;Rook/Queen&lt;/li&gt;
  &lt;li&gt;King&lt;/li&gt;
  &lt;li&gt;Drawing away a defender&lt;/li&gt;
  &lt;li&gt;Driving away the enemy king&lt;/li&gt;
  &lt;li&gt;Queen&lt;/li&gt;
  &lt;li&gt;Bishop&lt;/li&gt;
  &lt;li&gt;Knight&lt;/li&gt;
  &lt;li&gt;Rook&lt;/li&gt;
  &lt;li&gt;Queen sacrifice&lt;/li&gt;
  &lt;li&gt;Rook mates&lt;/li&gt;
  &lt;li&gt;Rook checks
    1. enemy rook interposes, bishop mates
    2. enemy piece interposes, back-rank combination&lt;/li&gt;
  &lt;li&gt;Mating a hemmed-in King&lt;/li&gt;
  &lt;li&gt;Hemming the king, sacrificing and mating
    &lt;h2 id=&quot;the-defenses&quot;&gt;The Defenses&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Capturing a checking piece with appropriate piece&lt;/li&gt;
  &lt;li&gt;Interposing&lt;/li&gt;
  &lt;li&gt;King fleeing
    &lt;h2 id=&quot;pins&quot;&gt;Pins&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Pinned piece cannot capture&lt;/li&gt;
  &lt;li&gt;However it can support a checkmate&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 28 Oct 2019 14:15:00 +0000</pubDate>
        <link>https://adityagupta1089.github.io/chess/notes/bobby-fischer-teaches-chess.html</link>
        <guid isPermaLink="true">https://adityagupta1089.github.io/chess/notes/bobby-fischer-teaches-chess.html</guid>
        
        
        <category>Chess</category>
        
        <category>Notes</category>
        
      </item>
    
      <item>
        <title>Strassen Matrix Multiplication</title>
        <description>&lt;p&gt;The product of two $n\times n$ matrices $X$ and $Y$ which takes $O(n^3)$&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
X=\begin{bmatrix}A&amp;B\\C&amp;D\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
Y=\begin{bmatrix}E&amp;F\\G&amp;H\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;is 
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
XY=\begin{bmatrix}A&amp;B\\C&amp;D\end{bmatrix}\begin{bmatrix}E&amp;F\\G&amp;H\end{bmatrix}=\begin{bmatrix}AE+BG&amp;AF+BH\\CE+DG&amp;CF+DH\end{bmatrix} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;here $T(n)=8T(n/2)+O(n^2)\implies O(n^3)$&lt;/p&gt;

&lt;p&gt;Strassen gave:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
XY=\begin{bmatrix}P_5+P_4-P_2+P_6&amp;P_1+P_2\\P_3+P_4&amp;P_1+P_5-P_3-P_7\end{bmatrix}
\ %]]&gt;&lt;/script&gt;

&lt;p&gt;where&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
P_1&amp;=A(F-H)&amp;P_5&amp;=(A+D)(E+H)\\
P_2&amp;=(A+B)H&amp;P_6&amp;=(B-D)(G+H)\\
P_3&amp;=(C+D)E&amp;P_7&amp;=(A-C)(E+F)\\
P_4&amp;=D(G-E)\\
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;The new running time is $T(n)=7T(n/2)+O(n^2)$ which by the master theorem works out to be $O(n^{\log_27})\approx O(n^{2.81})$&lt;/p&gt;
</description>
        <pubDate>Sat, 26 Oct 2019 18:46:00 +0000</pubDate>
        <link>https://adityagupta1089.github.io/notes/algorithms/matrix-multiplication.html</link>
        <guid isPermaLink="true">https://adityagupta1089.github.io/notes/algorithms/matrix-multiplication.html</guid>
        
        
        <category>Notes</category>
        
        <category>Algorithms</category>
        
      </item>
    
      <item>
        <title>Mergesort, Quicksort and Quickselect</title>
        <description>&lt;h1 id=&quot;mergesort&quot;&gt;Mergesort&lt;/h1&gt;

&lt;p&gt;Split the list into 2 halves, recursively sort each half and then merge the two sorted sublists. For merging $x[1..k]$ and $y[1..l]$ into $z[1..k+l]$. The first element of $z$ is smaller of $x[1]$ and $y[1]$ and rest can be constrcuted recrusively.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\text{mergesort}(a[1..n]) =&amp;\text{merge}(\text{mergesort}(a[1..\lfloor n/2\rfloor]),\\&amp;\quad\text{mergesort}(a[\lfloor n/2\rfloor+1...n]))\\
\text{merge}(x[1..k],y[1..l])=&amp;\begin{cases}x[1]\circ\text{merge}(x[2..k],y[1..l])&amp;x[1]\le y[1]\\y[1]\circ\text{merge}(x[1..k],y[2..l])&amp;\text{otherwise}\end{cases}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Time Complexity $T(n)=2T(n/2)+O(n)\implies O(n\log n)$&lt;/p&gt;

&lt;h1 id=&quot;quicksort--quickselect&quot;&gt;Quicksort &amp;amp; Quickselect&lt;/h1&gt;

&lt;p&gt;Select a pivot $v$ (pick randomly). Split the array into three categories: elements smaller than $v$, those equal to $v$ and those greater than $v$. Call these $S_L$, $S_v$, and $S_R$ respectively. Recursively sort the array.&lt;/p&gt;

&lt;p&gt;Time complexity: $O(n^2)$ worst case. $O(n\log n)$ best and average case.&lt;/p&gt;

&lt;p&gt;For selecting the $k^{\rm th}$ element:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\text{selection}=
\begin{cases}
\text{selection(S_L, k)}&amp;k\le |S_L|\\
v &amp;|S_L|&lt;k\le|S_L|+|S_v|\\
\text{selection}(S_R, k-|S_L|-|S_v|)&amp;k&gt;|S_L|+|S_v|
\end{cases} %]]&gt;&lt;/script&gt;
Time complexity: $T(n)=T(n/2)+O(n)\implies O(n)$&lt;/p&gt;
</description>
        <pubDate>Sat, 26 Oct 2019 18:35:00 +0000</pubDate>
        <link>https://adityagupta1089.github.io/notes/algorithms/mergesort-quicksort-quickselect.html</link>
        <guid isPermaLink="true">https://adityagupta1089.github.io/notes/algorithms/mergesort-quicksort-quickselect.html</guid>
        
        
        <category>Notes</category>
        
        <category>Algorithms</category>
        
      </item>
    
  </channel>
</rss>
